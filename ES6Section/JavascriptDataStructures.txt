      JAVASCRIPT DATA STRUCTURES

Source: https://www.youtube.com/watch?v=poGEVboh9Rw&list=PLC3y8-rFHvwg6nsAOfC5Is18KB2DrVOJy&ab_channel=Codevolution

Cada lenguaje tiene su Set de data structures.En este curso veremos las que tiene disponible Javascript.
Es posible implementar una estructura de datos en diferentes maneras.
No debo memorizar la implementación,sino entenderla.

Que es una estructura de datos? Una estructura de datos es una manera de organizar y almacenar datos de forma que puedan ser usados eficientemente.
Una estructura de datos es una colección de valores,las relaciones entre ellos y las funciones u operaciones que pueden ser aplicadas a esa estructura.

Usar una estructura de datos adecuada hará que una función se comporte eficientemente o no.Además,también me ayudará a solucionar los problemas de una forma más eficiente,tanto en espacio como en tiempo.
Aprender sobre estructuras de datos también me dará mayor conocimiento sobre ciertas cosas que ya deberia conocer como:
  DOM - Tree data structure 
  Browser back and forward funtionality - Stack data structure
  OS job scheduling <- Queue data structure(colas)

En el curso veré las siguientes estructuas en esta secuencia:
1- Built in data structures
  - Arrays
  - Objects
  - Sets
  - Maps
2- Custom data structures
  - Stacks
  - Queues
  - Circular queues
  - Linked lists
  - Hash tables
  - Trees
  - Graphs
Al final del curso tendré un conocimiento profundo de estructuras de datos en JS.

      VIDEO 02 ARRAY DATA STRUCTURE

An array is a data structure that can hold a collection of values
Arrays can contain a mix of different data types in JS.You can mix strings,booleans,numbers,...all in the same array 
Arrays are resizable.You don't have to declare the size of an array before creating it.
Javascript arrays are zero-indexed and the insertion order is maintained.
Arrays are iterables.
const arr = [1, 2, 3, "Vishno", true];
arr.push(4);
arr.unshift(0);
// console.log(arr[0]);
for (const item of arr) {
  console.log(item);
}
// recuerda que puedo eliminar un item al final del array con arr.pop() y al principio con arr.shift()
// map, filter,reducer,concat,slice and splice are very common too
// insert or remove from end is O(1) constant <- push y pop o simplemente usando el ultimo index,no tiene por que ser con push o pop
// insert or remove from beginning is O(n) linear <- unshift y shift
// accesing any position is O(1)
// searching is O(n)
// shift,unshift,concat,slice,splice - O(n) linear
// forEach/map/filter/reduce - also O(n) linear

Fijate que usar un forEach y dentro un map dispara la time complexity a cuadratic O(n^2) y en una entrevista puede que no quieran eso

VIDEO 03 OBJECT DATA STRUCTURE

An object is an unordered collection ok key-value pairs.The key must either ve a sring or symbol data type where as the value can be of any data type.
To retrieve a value,you can use the correspoding key.This can be achieved using the dot notation or bracket notation.
An object is not iterable(not for of as when using arrays)
TIP:recuerda que al usar la bracket notation tengo que pasar un string:
const obj = {
  name: 'Peter',
  age: 20
}
console.log(obj[age]) <- dará error,tengo que usar obj['age']

Puedo añadir key-value pairs usando la notación del punto:
obj.hobby = "football";
Puedo remover una propiedad con el operador delete:
delete obj.age;

Perfectamente se pueden agregar funciones como values:
const obj = {
  name: 'Peter',
  age: 23,
  sayMyName: function(){ console.log(this.name)}
}

 En Javascript se usan mucho estos tres métodos estáticos: Object.keys(obj) | Object.values(obj) | Object.entries(obj) para acceder a las keys,los values,o ambos.Estas funciones siempre devuelven un arreglo.

 Time complexity:
 Insert O(1) constant
 Remove O(1) constant
 Accesss O(1) constant
 * Fijate que insertar,remover o acceder se hace mediante la key y por ello es constante(1 operación a memoria ??)

 Search O(n) <- sin embargo buscar es linear
 Object.keys() es O(n) pues tiene que iterar por todos los pares
 Object.values() es O(n) <- lo mismo
 Object.entries() es O(n) <- lo mismo

      VIDEO 04 SET DATA STRUCTURE

Esta estructura fue introducida en Javascript en el ECMA2015.
A set is a data structure that can hold a collection of values.The values however must be unique.
Set can contain a mix of different data types.You can store strings,booleans,numbers or even objects all in the same set.
Sets are dynamically sized.You don't have to declare the size of a set before creating it(same as arrays)
Sets do not maintain an insertion order.
Sets are iterable.They can be iterated through a for of loop(rp will work as well)

Set vs Arrays:
Arrays can contain duplicate values whereas Sets cannot
Insertion order is maintained in arrays but it is not the case with Sets
Searching and deleting an element in the set is faster compared to arrays(porque??)

// para crear un set tengo la clase Set(iterable) que permite crear un Set desde un iterable
const set = new Set([1,2,3])
// para añadir a un Set tengo el método set.add()
set.add(4)
// un Set va a ignorar valores duplicados
set.add(4)
// puedo comprobar si un Set tiene un determinado valor con Set.has(value) <- dado que iterará será O(n)
set.has(2)
set.forEach(i => console.log(i))

// para borrar tengo el método delete
set.delete(3)
// para contar el numero de elementos tengo la propiedad size,igual que length para arrays.Es una propiedad
console.log(set.size)
// para vaciar un Set tengo el método clear:
set.clear()
console.log(set.size)

        EXTRA MAKE CODE FASTER USING SETS IN JAVASCRIPT

Source: https://bretcameron.medium.com/how-to-make-your-code-faster-using-javascript-sets-b432457a4a77

Lo primero de todo es entender que los arrays son colecciones indexadas.Es decir que el valor de los datos en un array está ordenado por un indice(de ahi que acceder a arr[3] sea O(1) constante,asinto).Por otro lado,los Sets son colecciones basadas en keys(keyed collections).En vez de usar indices,usan una key.Un Set es iterable(siempre en el orden de inserción que tuvo) y no puede contener datos duplicados.
De forma directa un Set tiene varias ventajas sobre un arreglo:
1- buscar(usando indexOf or includes) en un array es más lento
2- borrar es más lento(ya que tiene que mover los indices)
3- Insertar: de nuevo es más rapido añadir a un Set que a un array(discutible)
4- Storing NaN: en un Set se puede guardar este valor
5- Remover duplicados:en un Set ya se da esto de forma natural(siempre que sea lo que queremos)

Mientras que los métodos para buscar en un array son O(n) linear las operaciones de buscar,borrar e insertar todas tienen complejidad O(1) (ya que insertamos al finaly borramos o buscamos por key).Fijate que daría igual el tamaño de la colección a la hora de buscar o borrar(diferente al array).
NOTA:fijate que set.has() tiene complejidad constante tmb(a diferencia de lo que pensaba antes)
Pasar de Array a Set= new Set([1,2,3,4])
Pasar de Set a Array= [...new Set([1,2,3,4])]

[4,1,3,5] 9
const findSum = (arr,sum) => arr.some((set => n => set.has(n) || !set.add(sum -n) )(new Set));
const findSum = (arr,sum) => arr.some( (set => (n) => set.has(n) || !set.add(sum -n) )(new Set));

VIDEO 05 MAP DATA STRUCTURE

A Map is an ordered collection of key-value pairs.Both keys and values can be of any data type
To retrieve a value,you can use the corresponding key.
Finally,Maps are iterable.They can be used with a for of loop,among others.
* Fijate que hasta ahora el único no iterable es un objeto.

Object vs Map(dado que son muy parecidos veamos las diferencias entre ellos):
  1- Objects are unordered whereas maps are ordered
  2- Keys in objects can only be string or symbol type whereas in maps,they can be of any type
  3- An object has a prototype an may contain a few default keys wich may collide with your own keys if you're not careful.A map on the other hand does not contain any keys by default.
  4- Objects are not iterable whereas Maps are iterable
  5- The number of items in an object must be determined manually(tengo que contar las keys) mientras que en un Map tengo la propiedad size(as well as in a Set)
  6- Puedo atar funcionalidad a un Objeto(function as values) mientras que en un Map solo puedo almacenar data

const map = new Map([ ['pais':'España'] , ['edad':25] , ['nombre':'Asinto'] ])
for(const [k,v] of map){
  console.log(`${k}: ${v}`);
}

// para añadir un nuevo valor tengo el metodo map.set(k,v) que obviamente pide dos argumentos(la clave la pide como string)
map.set('d',4);
// si quiero comproba si una KEY existe tengo el método has:
console.log(map.has('b'))
// si quiero borrar un par de clave valor tengo el método delete(key) que borrará la pareja mediante la key
map.delete('a')
// de nuevo puedo ver su numero de elementos con la propiedad size
console.log(map.size)
// de nuevo puedo vaciar el Map con el método clear()
map.clear()

VIDEO 06-07 STACK DATA STRUCTURE

The stack data structure is a sequential collection of elements that follows the principle of Last In First Out (LIFO)
The last element inserted into the stacks is the first element to be removed
A stack of plates is a common analogy.
A Stack is a simple List,but it is defined by its behavior(favor-behavior)
The Stack data structure supports two main operations:
  - Push, which adds an element to the collection
  - Pop,  which removes the most recently added element
That is,there are only operations in the last index

Usage(helpful situations):
 - Helps when you have to trace back your steps(browser history go back/go forward or REDO/ UNDO)
 - The most important: the call stack used in Javascript runtime 

Implementación:
class Stack {
  constructor() {
    this.items = [];
  }
  // given that we have to push an element push method has to accept that element has parameter
  push(element) {
    this.items.push(element);
  }

  pop() {
    return this.items.pop();
  }
  // return the last element without removing it
  peek() {
    return this.items[this.items.length - 1];
  }

  isEmpty() {
    return this.items.length === 0;
  }
  size() {
    return this.items.length;
  }
  print() {
    console.log(this.items.toString());
  }
}

const stack = new Stack();
console.log(stack.isEmpty());
stack.push(20);
stack.push(10);
stack.push(30);
console.log(stack.size());
console.log(stack.print());
console.log(stack.pop());
console.log(stack.peek());

Fijate que es un Array con restricciones.Dado que sus operaciones son sobre el último indice son O(1) constante.

    VIDEO 08-09 QUEUE DATA STRUCTURE

The Queue data structure is a sequential collection of elements that follows the principle of First In First Out(FIFO)
A common analogy is a group of people waiting in line.
The first element inserted into the queue is first element to be removed(array.push)

Again,a Queue is defined by its behavior and is a simple array with restrictions.It has two simple operations,enqueue and dequeue(meter/sacar de la cola)
  - Enqueue, which adds an element to the tail of the collection(unshift)
  - Dequeue, which removes at the first index(push)

Usefulness: typically a Queue is useful for chain of tasks:
 - Printers
 - CPU task scheduling 
 - Callback queue that is used in Javascript runtime

 Implementation:
 class Queue {
  constructor() {
    this.items = [];
  }
  // recuerda que una Queue inserta al final,pero remueve al principio
  enqueue(element) {
    this.items.push(element);
  }
  // recuerda que una Queue inserta al final,pero remueve al principio
  dequeue() {
    return this.items.shift();
  }
  isEmpty() {
    return this.items.length === 0;
  }
  // esta vez peek va a devolver el primero,ojo
  peek() {
    return this.isEmpty() ? null : this.items[0];
  }
  size() {
    return this.items.length;
  }
  print() {
    console.log(this.items.toString());
  }
}

const queue = new Queue();
console.log(queue.isEmpty());
queue.enqueue(10);
queue.enqueue(20);
queue.enqueue(30);
console.log(queue.size());
queue.print();
console.log(queue.dequeue());
console.log(queue.peek());

Fijate que dequeue al llamar a shift tiene coste O(n) linear.En el siguiente video veremos como implementar una COLA tipo FIFO con un objeto y con costes O(1) 

      VIDEO 10 QUEUE IMPLEMENTATION OPTIMISED

En este video implementaremos una Queue usando un Object asegurandonos asi que no usamos Array.shift() por su time complexity.La clave va a estar en usar un Object y dos punteros:
class Queue {
  constructor() {
    this.items = {};
      // necesitamos dos punteros más,apuntando al final y al principio
    this.rear = 0;
    this.front = 0;
  }
  // encolar al final
  enqueue(element){
   this.items[this.rear] = element 
   this.rear++;
  }
// desencolar al principio(shift).Fijate que vamos a devolver el item.Aqui está la clave de la performance,ya que accedemos directamente,sin iterar
  dequeue(){
    const item = this.items[this.front]; 
    if(!item) return;
    delete this.items[this.front]
    this.front++;
    return item;
  }
  isEmpty(){
    // si los punteros apuntan a la misma posición esta vacio
    return this.rear - this.front === 0
  }
  
  peek(){
     return this.items[this.front] ;
  }

  size(){
    return this.rear - this.front;
  }
  print(){
    console.log(this.items)
  }
}

const queue = new Queue();
console.log(queue.isEmpty())
queue.enqueue(10)
queue.enqueue(20)
queue.enqueue(30)
console.log(queue.size())
queue.print()
console.log(queue.dequeue())
console.log(queue.peek())  

      VIDEO 11-12 CIRCULAR QUEUE

The circular queue is an extension of the standard version.The size of the queue is fixed and a single block of memory is used as if the first element is connected to the last element
It is also referred to as circular buffer or ring buffer and follows the FIFO principle.
A circular queue will reuse the empty block created during the dequeue operation
Por todo esto,si tengo que trabajar con queues y sé su longitud máxima,usar una circular queue como implementación suele ser una buena idea
The circular Queue data structure supports two main operations:
  1- Enqueue: which adds elements to the rear/tail of the collection
  2- Dequeue: which removes an element from the front/head of the collection 

NOTA,si la collection esta llena no puedo encolar más(gráficamentes es una grafica circular,con X particiones)
Usage:
  1- Clock
  2- Streaming data
  3- Computed control traffic lights

Implementación(fijate en el uso de 4 punteros):
class CircularQueue {
  constructor(capacity) {
    //  remember that the circular queue has a fixed capacity
    this.items = new Array(capacity);
    // we need the size stored in a variable for modularizing operations(this.front + 1) % this.capacity
    this.capacity = capacity;
    // we need the currentLength in all moment
    this.currentLength = 0;
    // también vamos a tener dos punteros que de momento apuntan afuera de la structure
    this.rear = -1;
    this.front = -1;
  }
  // si el currentLength es igual obviously is full
  isFull() {
    return this.currentLength === this.capacity;
  }
  // it will be empty if currentLength is zero
  isEmpty() {
    return this.currentLength === 0;
  }
  // si no está lleno recuerda que una Queue inserta al final luego incrementamos this.rear y asignamos con su nuevo indice.Movemos los punteros restantes
  enqueue(element) {
    if (!this.isFull()) {
      // si rear es 6 será 2(tiene que dar una vuelta)
      this.rear = (this.rear + 1) % this.capacity;
      this.items[this.rear] = element;
      this.currentLength++;
      // si front apuntaba a -1 lo movemos al mismo indice que apunte el rear(fijate que se quedará en el indice 0)
      if (this.front === -1) {
        this.front = this.rear;
      }
    }
  }
  // si la cola no está vacia reasignamos a null en el front y movemos punteros
  dequeue() {
    if (!this.isEmpty()) {
      const item = this.items[this.front];
      // dado que no queremos disminuir el array asignamos un null a this.front
      this.items[this.front] = null;
      // movemos el puntero del front
      this.front = (this.front + 1) % this.capacity;
      this.currentLength--;
      // si quedará vacia la cola(solo habia un elemento) sacamos los punteros afuera
      if (this.isEmpty()) {
        this.front = -1;
        this.rear = -1;
      }
      return item;
    }
  }

  peek() {
    if (!this.isEmpty()) {
      return this.items[this.front];
    }
    return null;
  }

  print() {
    if (this.isEmpty()) {
      console.log("Queue is empty");
    } else {
      let i;
      let str = "";
      // fijate que para iterar la circular queue podria estar en cualquier estado
      for (i = this.front; i !== this.rear; i = (i + 1) % this.capacity) {
        str += this.items[i] + " ";
      }
      str += this.items[i];
      console.log(str);
    }
  }
}

VIDEO 13-14 LINKED LIST

A linked list is a linear data structure that includes a series of connected nodes
Each node consists of a data value and a pointer that points to the next node
As an advantage the elements in a linked list can be easily inserted or removed withour reallocation of the entire stucture(recuerda que no usan posiciones contigüas de memoria)
As an disadvantage,the random access of elements is not feasible and accesing an element has linear time complexity(given that you have to start from the first node)
A Linked List data structure supports three main operations:
  1- Insertion: to add an element at the beggining,end or at a given index
  2- deletion: to remove an item given its index or value
  3- Search: to find an element given its value
NOTA: the very last node points to null

USAGE: all applications of stacks and queues are applications of linked lists
An Image Viewer(cada imagen apunta a la siguiente o anterior)
NOTA: se usa masivamente asi que es una pregunta muy usada en entrevistas

Implementación(fijate que por primera vez vamos a usar dos clases y que una LinkedList siempre debe saberse el punto de entrada)

class Node {
  constructor(value){
    this.value = value
    // aparte del value necesitamos el puntero al siguiente nodo que en principio apunta a null
    this.next = null
  }
}

// en una LinkedList siempre va a haber un puntero hacia el primer elemento(de otra forma no sabriamos entrar a la colección,sin saber quien es el primer Node)
// ese puntero se le suele llamar head y obviamente hasta que no haya un Node apunta a null
class LinkedList {
  constructor(){
    this.head = null //puntero del node de entrada
    this.size = 0   // llevaremos un registro del size
  }

  isEmpty(){
    return this.size === 0;
  }

  getSize(){
    return this.size;
  }

}

TIP: memorize that 'the last' and 'the very last' both have the same meaning,but the very last has lot of enphasis in 'last',even having a little of negative context about the situation:
> for the very last time,don't do that <- it is the last time,it is important to me that it is the last time I will warn you
> I saw her last time on Wednesday, I think <- it is not really important that it was the last time I saw her

Same with any other word(for the very first time(remarco que es la primera vez), for own very safety(es importante remarcar que es por nuestra seguridad,etc,asinto))

      VIDEO 15 PREPEND A NODE(at the very beginning <- begin is consonant + vowel + consonant)

prepend(value){
  const node = new Node(value); <- creamos el Node lo primero
  if(!this.isEmpty()) this.next = this.head; <- si agregamos al principio sobre una list con elementos el next del nuevo node apuntará al viejo head
  this.head = node <- el head apuntará al very node itself,pues es una prepend opt
  this.size++; <- aumentamos el size
}

      VIDEO 16 PRINT THE LINKED LIST

print(){
  if(this.isEmpty()){
    console.log('The list is empty')
  } else{
    let curr = this.head;
    let listValues = '';
    while(curr){
      listValues += `${curr.value}`
      curr = curr.next
    }
    console.log(listValues)
  }
}

    VIDEO 17 APPEND TO A NODE

We will append a new node to the list.The node will contain a value and a pointer to the nex Node(to null).Fijate que tengo que contemplar el caso de que el append sea sobre una LL vacia y si no lo fuera tengo que mover el último puntero que apunta a null y debe apuntar a este current node:

append(value) {
  const node = new Node(value);
  if(this.isEmpty()){
    this.head=node
  } else {
    let prev = this.head; <- fijate que no puedo mover el puntero y que solo puedo entrar por aqui a la linked list
    while(prev.next){
      prev=prev.next
    }
    prev.next=node; <- cuando llegue aqui estamos en el penultimo,que era el único null,cambiamos ese head para que apunte al actual
  } 
  this.size++;
}
Fijate que preprend es 0(1) pero append es O(n) por el bucle while.Un segundo puntero apuntando al last cambiaría esta performance a O(1)

NOTA: array.of() crea una nueva instancia de Array con un numero variable de elementos pasados por argumento:
Array.of(1,2,3)
* por otro lado, Array.from() crea una nueva instancia de Array a partir de un objeto iterable.Fijate que puede recibir un segundo argumento a aplicar al objeto iterable antes de crear el array.Este método parece bastante útil por ello
Array.from([1,2,3], x => x*2) <- creará [2,4,6] 
Array.from('foo') <-creará ['f','o','o']

VIDEO 18 INSERT IN A LINKED LIST

Esta vez vamos a insertar en una posicion dada.Fijate que insertar va a cambiar el puntero del inmediatamente anterior a la posición ya que su head apuntará al nuevo y el head del nuevo al que estaba en esa posición:

insert(value,index){
  if(index < 0 || index > this.size) return;
  if(index === 0) this.prepend(value);
  else{
    const node = new Node(value);

    let prev = this.head; <- guardo el puntero al head
    
    for(let i = 1; i < index;i++){
      prev=prev.next
    }
    node.next=prev.next; <- el next actual apuntará al anterior
    prev.next=node; <- y el del inmediato anterior al actual
    this.size++;
  }
}

        VIDEO 19 REMOVE AT CERTAIN INDEX

Given that we can remove at any index let's implement this method,taking into account/keeping in mind that the index can be out of bounds firstly:

  removeFrom(index) {
    if (index < 0 || index >= this.size) return console.log("index out of bounds");

    if (this.size === 1) {
      this.size--;
      return (this.head = null);
    }
    
    let prev = this.head;
    for (let i = 0; i < index - 1; i++) {
      prev = prev.next;
    }
    prev.value = prev.next.value;
    prev.next = prev.next.next;
    this.size--;
  }

Next case we will take into consideration that we can remove at index 0 when LinkedList having only one element,because of that the head has to re-point to null
Finally we can remove at any index,having to move the pointer of the previous element to point to the element moved to the hole we left when removing.For that purpose we need a pointer,etc

      VIDEO 20 REMOVE BY VALUE

The method will remove the first node which contains the given value by arguments.It will return the value if node is found or null when not finding it.Again we will have 3 scenarios, an empty LinkedList:
  removeValue(value) {
    if (this.isEmpty()) {
      return console.log("Linked List is empty.Nothing to remove");
    }
    // fijate que this.head es un object {value:any,next:any}
    // si solo hubiera un elemento tenemos this.head.value apuntando al value y this.head.next apuntando a null
    // si el puntero.value es igual sin haberlo movido solo puede ser en el primer indice
    if (this.head.value === value) {
      this.head = this.head.next;
      this.size--;
      return console.log(value);
    }else {
      // si no hay que ir moviendo el puntero,de nuevo asignamos una variable al puntero
      let prev = this.head;
      // mientras el puntero tenga un next y sea diferente del value avanzamos el puntero
      while(prev.next && prev.next.value !== value) {
        prev = prev.next;
      }
      // si sale del bucle o bien tenemos en prev.next todo el nodo o no lo ha encontrado.Si existe ese prev.next es que lo encontró.Si lo encontró: 
      if(prev.next){
        // el nodo a remover lo tenemos en el puntero.next
        const removedNode = prev.next
        // el puntero de éste nodo ahora debe apuntar al que apuntaba el removed.next
        prev.next = removedNode.next;
        // desde luego está todo bien claro, xd
        this.size--;
        return console.log(value)
      }
      return null;
    }
  }
  Esta vez ha sido un poco complejo,pero el approach que tomó me gusta mucho
  Removing a Node has linear time complexity as the node to be removed can be the last of the list

        VIDEO 21 LINKED LIST SEARCH

Let's implement how to find a Node given its value.It must return the index of the first ocurrence or -1 if it is not found
Si bien se puede usar la misma aproximación que antes se puede simplificar un poco:
  searchByAuthor(value) {
    if (this.isEmpty()) return -1;
    let i = 0;
    let curr = this.head;
    while (curr) {
      if (curr.value === value) {
        return i;
      }
      curr = curr.next;
      i++;
    }
    return -1;
  }
Muy pro el señor este

VIDEO 22 REVERSE LINKED LIST

Reversing a Linked List is a common interview question so let's tacke this.Fijate que esta reversión parece compleja de sacar sin ayuda.Necesitaré dos punteros,uno apuntando al nodo previo(luego al principio apunta a null) y otro nodo temporal apuntando al nodo siguiente(current.next).Además hay que realizar 4 movimientos(más uno final) por cada iteración.
Fijate en la slide que queda muy claro que invertimos el nodo en el eje Y,nada de arrays:

reverse(){
  let prev = null;
  let curr = this.head;
  // we need to perform 4 steps(+one last additional)
  while(curr){
    1 -crear el puntero temporal al next(si estoy en el uno me guardo a donde apunta el next de uno,por ejemplo sería el 2)
    let temp = curr.next; // puntero temporal
    2- hacer que el curr.next apunte al prev(cambio de horizontalidad)
    curr.next = prev
    3- actualizar prev a curr(diria que es reasignar todo el Nodo)
    prev = curr
    4- avanzar el puntero(lo tengo en el puntero del paso 1 el next)
    curr = temp;
  }
  queda cambiar el head,que sigue en la posicion 0
  this.head = prev
}

      VIDEO 22 LINKED LIST WITH POINTERS TO HEAD AND TAIL

Ya hemos visto una Linked List con un puntero al Head,veamos ahora