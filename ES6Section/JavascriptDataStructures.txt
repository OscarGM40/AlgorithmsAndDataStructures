      JAVASCRIPT DATA STRUCTURES

Source: https://www.youtube.com/watch?v=poGEVboh9Rw&list=PLC3y8-rFHvwg6nsAOfC5Is18KB2DrVOJy&ab_channel=Codevolution

Cada lenguaje tiene su Set de data structures.En este curso veremos las que tiene disponible Javascript.
Es posible implementar una estructura de datos en diferentes maneras.
No debo memorizar la implementación,sino entenderla.

Que es una estructura de datos? Una estructura de datos es una manera de organizar y almacenar datos de forma que puedan ser usados eficientemente.
Una estructura de datos es una colección de valores,las relaciones entre ellos y las funciones u operaciones que pueden ser aplicadas a esa estructura.

Usar una estructura de datos adecuada hará que una función se comporte eficientemente o no.Además,también me ayudará a solucionar los problemas de una forma más eficiente,tanto en espacio como en tiempo.
Aprender sobre estructuras de datos también me dará mayor conocimiento sobre ciertas cosas que ya deberia conocer como:
  DOM - Tree data structure 
  Browser back and forward funtionality - Stack data structure
  OS job scheduling <- Queue data structure(colas)

En el curso veré las siguientes estructuas en esta secuencia:
1- Built in data structures
  - Arrays
  - Objects
  - Sets
  - Maps
2- Custom data structures
  - Stacks
  - Queues
  - Circular queues
  - Linked lists
  - Hash tables
  - Trees
  - Graphs
Al final del curso tendré un conocimiento profundo de estructuras de datos en JS.

      VIDEO 02 ARRAY DATA STRUCTURE

An array is a data structure that can hold a collection of values
Arrays can contain a mix of different data types in JS.You can mix strings,booleans,numbers,...all in the same array 
Arrays are resizable.You don't have to declare the size of an array before creating it.
Javascript arrays are zero-indexed and the insertion order is maintained.
Arrays are iterables.
const arr = [1, 2, 3, "Vishno", true];
arr.push(4);
arr.unshift(0);
// console.log(arr[0]);
for (const item of arr) {
  console.log(item);
}
// recuerda que puedo eliminar un item al final del array con arr.pop() y al principio con arr.shift()
// map, filter,reducer,concat,slice and splice are very common too
// insert or remove from end is O(1) constant <- push y pop o simplemente usando el ultimo index,no tiene por que ser con push o pop
// insert or remove from beginning is O(n) linear <- unshift y shift
// accesing any position is O(1)
// searching is O(n)
// shift,unshift,concat,slice,splice - O(n) linear
// forEach/map/filter/reduce - also O(n) linear

Fijate que usar un forEach y dentro un map dispara la time complexity a cuadratic O(n^2) y en una entrevista puede que no quieran eso

VIDEO 03 OBJECT DATA STRUCTURE

An object is an unordered collection ok key-value pairs.The key must either ve a sring or symbol data type where as the value can be of any data type.
To retrieve a value,you can use the correspoding key.This can be achieved using the dot notation or bracket notation.
An object is not iterable(not for of as when using arrays)
TIP:recuerda que al usar la bracket notation tengo que pasar un string:
const obj = {
  name: 'Peter',
  age: 20
}
console.log(obj[age]) <- dará error,tengo que usar obj['age']

Puedo añadir key-value pairs usando la notación del punto:
obj.hobby = "football";
Puedo remover una propiedad con el operador delete:
delete obj.age;

Perfectamente se pueden agregar funciones como values:
const obj = {
  name: 'Peter',
  age: 23,
  sayMyName: function(){ console.log(this.name)}
}

 En Javascript se usan mucho estos tres métodos estáticos: Object.keys(obj) | Object.values(obj) | Object.entries(obj) para acceder a las keys,los values,o ambos.Estas funciones siempre devuelven un arreglo.

 Time complexity:
 Insert O(1) constant
 Remove O(1) constant
 Accesss O(1) constant
 * Fijate que insertar,remover o acceder se hace mediante la key y por ello es constante(1 operación a memoria ??)

 Search O(n) <- sin embargo buscar es linear
 Object.keys() es O(n) pues tiene que iterar por todos los pares
 Object.values() es O(n) <- lo mismo
 Object.entries() es O(n) <- lo mismo

      VIDEO 04 SET DATA STRUCTURE

Esta estructura fue introducida en Javascript en el ECMA2015.
A set is a data structure that can hold a collection of values.The values however must be unique.
Set can contain a mix of different data types.You can store strings,booleans,numbers or even objects all in the same set.
Sets are dynamically sized.You don't have to declare the size of a set before creating it(same as arrays)
Sets do not maintain an insertion order.
Sets are iterable.They can be iterated through a for of loop(rp will work as well)

Set vs Arrays:
Arrays can contain duplicate values whereas Sets cannot
Insertion order is maintained in arrays but it is not the case with Sets
Searching and deleting an element in the set is faster compared to arrays(porque??)

// para crear un set tengo la clase Set(iterable) que permite crear un Set desde un iterable
const set = new Set([1,2,3])
// para añadir a un Set tengo el método set.add()
set.add(4)
// un Set va a ignorar valores duplicados
set.add(4)
// puedo comprobar si un Set tiene un determinado valor con Set.has(value) <- dado que iterará será O(n)
set.has(2)
set.forEach(i => console.log(i))

// para borrar tengo el método delete
set.delete(3)
// para contar el numero de elementos tengo la propiedad size,igual que length para arrays.Es una propiedad
console.log(set.size)
// para vaciar un Set tengo el método clear:
set.clear()
console.log(set.size)

VIDEO 05 MAP DATA STRUCTURE

A Map is an ordered collection of key-value pairs.Both keys and values can be of any data type
To retrieve a value,you can use the corresponding key.
Finally,Maps are iterable.They can be used with a for of loop,among others.
* Fijate que hasta ahora el único no iterable es un objeto.

Object vs Map(dado que son muy parecidos veamos las diferencias entre ellos):
  1- Objects are unordered whereas maps are ordered
  2- Keys in objects can only be string or symbol type whereas in maps,they can be of any type
  3- An object has a prototype an may contain a few default keys wich may collide with your own keys if you're not careful.A map on the other hand does not contain any keys by default.
  4- Objects are not iterable whereas Maps are iterable
  5- The number of items in an object must be determined manually(tengo que contar las keys) mientras que en un Map tengo la propiedad size(as well as in a Set)
  6- Puedo atar funcionalidad a un Objeto(function as values) mientras que en un Map solo puedo almacenar data

const map = new Map([ ['pais':'España'] , ['edad':25] , ['nombre':'Asinto'] ])
for(const [k,v] of map){
  console.log(`${k}: ${v}`);
}

// para añadir un nuevo valor tengo el metodo map.set(k,v) que obviamente pide dos argumentos(la clave la pide como string)
map.set('d',4);
// si quiero comproba si una KEY existe tengo el método has:
console.log(map.has('b'))
// si quiero borrar un par de clave valor tengo el método delete(key) que borrará la pareja mediante la key
map.delete('a')
// de nuevo puedo ver su numero de elementos con la propiedad size
console.log(map.size)
// de nuevo puedo vaciar el Map con el método clear()
map.clear()

VIDEO 06-07 STACK DATA STRUCTURE

The stack data structure is a sequential collection of elements that follows the principle of Last In First Out (LIFO)
The last element inserted into the stacks is the first element to be removed
A stack of plates is a common analogy.
A Stack is a simple List,but it is defined by its behavior(favor-behavior)
The Stack data structure supports two main operations:
  - Push, which adds an element to the collection
  - Pop,  which removes the most recently added element
That is,there are only operations in the last index

Usage(helpful situations):
 - Helps when you have to trace back your steps(browser history go back/go forward or REDO/ UNDO)
 - The most important: the call stack used in Javascript runtime 

Implementación:
class Stack {
  constructor() {
    this.items = [];
  }
  // given that we have to push an element push method has to accept that element has parameter
  push(element) {
    this.items.push(element);
  }

  pop() {
    return this.items.pop();
  }
  // return the last element without removing it
  peek() {
    return this.items[this.items.length - 1];
  }

  isEmpty() {
    return this.items.length === 0;
  }
  size() {
    return this.items.length;
  }
  print() {
    console.log(this.items.toString());
  }
}

const stack = new Stack();
console.log(stack.isEmpty());
stack.push(20);
stack.push(10);
stack.push(30);
console.log(stack.size());
console.log(stack.print());
console.log(stack.pop());
console.log(stack.peek());

Fijate que es un Array con restricciones.Dado que sus operaciones son sobre el último indice son O(1) constante.

    VIDEO 08-09 QUEUE DATA STRUCTURE

The Queue data structure is a sequential collection of elements that follows the principle of First In First Out(FIFO)
A common analogy is a group of people waiting in line.
The first element inserted into the queue is first element to be removed(array.push)

Again,a Queue is defined by its behavior and is a simple array with restrictions.It has two simple operations,enqueue and dequeue(meter/sacar de la cola)
  - Enqueue, which adds an element to the tail of the collection(unshift)
  - Dequeue, which removes at the first index(push)

Usefulness: typically a Queue is useful for chain of tasks:
 - Printers
 - CPU task scheduling 
 - Callback queue that is used in Javascript runtime

 Implementation:
 class Queue {
  constructor() {
    this.items = [];
  }
  // recuerda que una Queue inserta al final,pero remueve al principio
  enqueue(element) {
    this.items.push(element);
  }
  // recuerda que una Queue inserta al final,pero remueve al principio
  dequeue() {
    return this.items.shift();
  }
  isEmpty() {
    return this.items.length === 0;
  }
  // esta vez peek va a devolver el primero,ojo
  peek() {
    return this.isEmpty() ? null : this.items[0];
  }
  size() {
    return this.items.length;
  }
  print() {
    console.log(this.items.toString());
  }
}

const queue = new Queue();
console.log(queue.isEmpty());
queue.enqueue(10);
queue.enqueue(20);
queue.enqueue(30);
console.log(queue.size());
queue.print();
console.log(queue.dequeue());
console.log(queue.peek());

Fijate que dequeue al llamar a shift tiene coste O(n) linear.En el siguiente video veremos como implementar una COLA tipo FIFO con un objeto y con costes O(1) 

      VIDEO 10 QUEUE IMPLEMENTATION OPTIMISED

En este video implementaremos una Queue usando un Object asegurandonos asi que no usamos Array.shift() por su time complexity.La clave va a estar en usar un Object y dos punteros:
class Queue {
  constructor() {
    this.items = {};
      // necesitamos dos punteros más,apuntando al final y al principio
    this.rear = 0;
    this.front = 0;
  }
  // encolar al final
  enqueue(element){
   this.items[this.rear] = element 
   this.rear++;
  }
// desencolar al principio(shift).Fijate que vamos a devolver el item.Aqui está la clave de la performance,ya que accedemos directamente,sin iterar
  dequeue(){
    const item = this.items[this.front]; 
    if(!item) return;
    delete this.items[this.front]
    this.front++;
    return item;
  }
  isEmpty(){
    // si los punteros apuntan a la misma posición esta vacio
    return this.rear - this.front === 0
  }
  
  peek(){
     return this.items[this.front] ;
  }

  size(){
    return this.rear - this.front;
  }
  print(){
    console.log(this.items)
  }
}

const queue = new Queue();
console.log(queue.isEmpty())
queue.enqueue(10)
queue.enqueue(20)
queue.enqueue(30)
console.log(queue.size())
queue.print()
console.log(queue.dequeue())
console.log(queue.peek())  

      VIDEO 11-12 CIRCULAR QUEUE

The circular queue is an extension of the standard version.The size of the queue is fixed and a single block of memory is used as if the first element is connected to the last element
It is also referred to as circular buffer or ring buffer and follows the FIFO principle.
A circular queue will reuse the empty block created during the dequeue operation
Por todo esto,si tengo que trabajar con queues y sé su longitud máxima,usar una circular queue como implementación suele ser una buena idea
The circular Queue data structure supports two main operations:
  1- Enqueue: which adds elements to the rear/tail of the collection
  2- Dequeue: which removes an element from the front/head of the collection 

NOTA,si la collection esta llena no puedo encolar más(gráficamentes es una grafica circular,con X particiones)
Usage:
  1- Clock
  2- Streaming data
  3- Computed control traffic lights

Implementación(fijate en el uso de 4 punteros):
class CircularQueue {
  constructor(capacity) {
    //  remember that the circular queue has a fixed capacity
    this.items = new Array(capacity);
    // we need the size stored in a variable for modularizing operations(this.front + 1) % this.capacity
    this.capacity = capacity;
    // we need the currentLength in all moment
    this.currentLength = 0;
    // también vamos a tener dos punteros que de momento apuntan afuera de la structure
    this.rear = -1;
    this.front = -1;
  }
  // si el currentLength es igual obviously is full
  isFull() {
    return this.currentLength === this.capacity;
  }
  // it will be empty if currentLength is zero
  isEmpty() {
    return this.currentLength === 0;
  }
  // si no está lleno recuerda que una Queue inserta al final luego incrementamos this.rear y asignamos con su nuevo indice.Movemos los punteros restantes
  enqueue(element) {
    if (!this.isFull()) {
      // si rear es 6 será 2(tiene que dar una vuelta)
      this.rear = (this.rear + 1) % this.capacity;
      this.items[this.rear] = element;
      this.currentLength++;
      // si front apuntaba a -1 lo movemos al mismo indice que apunte el rear(fijate que se quedará en el indice 0)
      if (this.front === -1) {
        this.front = this.rear;
      }
    }
  }
  // si la cola no está vacia reasignamos a null en el front y movemos punteros
  dequeue() {
    if (!this.isEmpty()) {
      const item = this.items[this.front];
      // dado que no queremos disminuir el array asignamos un null a this.front
      this.items[this.front] = null;
      // movemos el puntero del front
      this.front = (this.front + 1) % this.capacity;
      this.currentLength--;
      // si quedará vacia la cola(solo habia un elemento) sacamos los punteros afuera
      if (this.isEmpty()) {
        this.front = -1;
        this.rear = -1;
      }
      return item;
    }
  }

  peek() {
    if (!this.isEmpty()) {
      return this.items[this.front];
    }
    return null;
  }

  print() {
    if (this.isEmpty()) {
      console.log("Queue is empty");
    } else {
      let i;
      let str = "";
      // fijate que para iterar la circular queue podria estar en cualquier estado
      for (i = this.front; i !== this.rear; i = (i + 1) % this.capacity) {
        str += this.items[i] + " ";
      }
      str += this.items[i];
      console.log(str);
    }
  }
}

VIDEO 13-14 LINKED LIST

A linked list is a linear data structure that includes a series of connected nodes
Each node consists of a data value and a pointer that points to the next node
As an advantage the elements in a linked list can be easily inserted or removed withour reallocation of the entire stucture(recuerda que no usan posiciones contigüas de memoria)
As an disadvantage,the random access of elements is not feasible and accesing an element has linear time complexity(given that you have to start from the first node)
A Linked List data structure supports three main operations:
  1- Insertion: to add an element at the beggining,end or at a given index
  2- deletion: to remove an item given its index or value
  3- Search: to find an element given its value
NOTA: the very last node points to null

USAGE: all applications of stacks and queues are applications of linked lists
An Image Viewer(cada imagen apunta a la siguiente o anterior)
NOTA: se usa masivamente asi que es una pregunta muy usada en entrevistas

Implementación(fijate que por primera vez vamos a usar dos clases y que una LinkedList siempre debe saberse el punto de entrada)

class Node {
  constructor(value){
    this.value = value
    // aparte del value necesitamos el puntero al siguiente nodo que en principio apunta a null
    this.next = null
  }
}

// en una LinkedList siempre va a haber un puntero hacia el primer elemento(de otra forma no sabriamos entrar a la colección,sin saber quien es el primer Node)
// ese puntero se le suele llamar head y obviamente hasta que no haya un Node apunta a null
class LinkedList {
  constructor(){
    this.head = null //puntero del node de entrada
    this.size = 0   // llevaremos un registro del size
  }

  isEmpty(){
    return this.size === 0;
  }

  getSize(){
    return this.size;
  }

}

TIP: memorize that 'the last' and 'the very last' both have the same meaning,but the very last has lot of enphasis in 'last',even having a little of negative context about the situation:
> for the very last time,don't do that <- it is the last time,it is important to me that it is the last time I will warn you
> I saw her last time on Wednesday, I think <- it is not really important that it was the last time I saw her

Same with any other word(for the very first time(remarco que es la primera vez), for own very safety(es importante remarcar que es por nuestra seguridad,etc,asinto))

      VIDEO 15 PREPEND A NODE(at the very beginning <- begin is consonant + vowel + consonant)

prepend(value){
  const node = new Node(value); <- creamos el Node lo primero
  if(!this.isEmpty()) this.next = this.head; <- si agregamos al principio sobre una list con elementos el next del nuevo node apuntará al viejo head
  this.head = node <- el head apuntará al very node itself,pues es una prepend opt
  this.size++; <- aumentamos el size
}

      VIDEO 16 PRINT THE LINKED LIST

print(){
  if(this.isEmpty()){
    console.log('The list is empty')
  } else{
    let curr = this.head;
    let listValues = '';
    while(curr){
      listValues += `${curr.value}`
      curr = curr.next
    }
    console.log(listValues)
  }
}
